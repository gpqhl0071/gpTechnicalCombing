# 悲观锁 

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，
所以**每次在拿数据的时候都会上锁**，
这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，
用完后再把资源转让给其它线程）。
传统的关系型数据库里边就用到了很多这种锁机制，
比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
**Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现**。

# 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，
所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。
**乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。**
在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。


# 使用场景

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，
像**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。
但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁**就比较合适。

参考：[https://github.com/Snailclimb/JavaGuide/blob/master/docs/essential-content-for-interview/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81.md](https://github.com/Snailclimb/JavaGuide/blob/master/docs/essential-content-for-interview/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81.md)


# 乐观锁常见的两种实现方式

## 1. 版本号机制

一般是在数据表中加上一个数据版本号**version字段**，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才**读取到的version值为当前数据库中的version值相等时才更新**，否则重试更新操作，直到更新成功。

## 2. CAS算法

即**compare and swap（比较与交换）**，是一种有名的无锁算法。

CAS的机制就相当于这种（非阻塞算法），
CAS是由CPU硬件实现，利用JNI来完成CPU指令的操作，所以执行相当快.
CAS有三个操作参数：**内存地址，期望值，要修改的新值**，
当期望值和内存当中的值进行比较不相等的时候，表示内存中的值已经被别线程改动过，
这时候失败返回，当相等的时候，将内存中的值改为新的值，并返回成功。


参考：[https://wchch.github.io/2017/12/28/CAS-Compare-and-Swap-%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/](https://wchch.github.io/2017/12/28/CAS-Compare-and-Swap-%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/)

**CAS缺点** 

- [ABA问题](https://hesey.wang/2011/09/resolve-aba-by-atomicstampedreference.html)
- 循环时间长开销大
- 只能保证一个共享变量的原子操作
- 比较花费CPU资源，即使没有任何争用也会做一些无用功。
- 会增加程序测试的复杂度，稍不注意就会出现问题。