消息中间件，也可以叫做中央消息队列或者是消息队列（区别于本地消息队列，本地消息队列指的是JVM内的队列实现），是一种独立的队列系统，消息中间件经常用来解决内部服务之间的
异步调用问题
。请求服务方把请求队列放到队列中即可返回，然后等待服务提供方去队列中获取请求进行处理，之后通过回调等机制把结果返回给请求服务方。


**常用的消息队列应用场景还有如下几个：** 

- **解耦** ： 一个业务的非核心流程需要依赖其他系统，但结果并不重要，有通知即可。
- **最终一致性** ： 指的是两个系统的状态保持一致，可以有一定的延迟，只要最终达到一致性即可。经常用在解决分布式事务上。
- **广播** ： 消息队列最基本的功能。生产者只负责生产消息，订阅者接收消息。
- **错峰和流控**

**如下消息中间件目前被经常应用**：

- ActiveMQ

- RabbitMQ

- RocketMQ

- Kafka

[更多参考](https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/data-communication/summary.md)



# 常见的消息队列对比

|对比方向   |概要   |
|---|---|
| 吞吐量	  |  万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。 |
| 可用性	  |  都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |
| 时效性	  |  RabbitMQ 基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。 |
| 功能支持  | 除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准  |
| 消息丢失  | ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。  |
