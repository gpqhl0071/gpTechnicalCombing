对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。

![11.png](http://ww1.sinaimg.cn/large/9b13c8fdly1g8n87s3zy4j21ap0pln4z.jpg)

**线程私有的：**

- 程序计数器(PC Register)
- 虚拟机栈(JVM language Stacks)
- 本地方法栈(Native method Stacks)


**线程共享的：**

- 堆(head)
- 方法区(Method Area)
- 直接内存 (非运行时数据区的一部分)


# 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

从上面的介绍中我们知道程序计数器主要有两个作用：

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
1. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

参考：[https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md)

# Java Stacks

Java 内存可以粗糙的区分为**堆内存（Heap）和栈内存
(Stack)**,其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。
（实际上，Java
虚拟机栈是由一个个栈帧组成，而**每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息**。）

局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、对象引用（reference
类型**，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。

- StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。
- OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。

# Native method Stacks

和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法
（也就是字节码）服务，而**本地方法栈则为虚拟机使用到的 Native 方法服务**。 在
HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

# Head

Java 虚拟机所管理的内存中最大的一块，**Java
堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存**。

Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected
Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java
堆还可以细分为：**新生代和老年代**

# Method Area

方法区与 Java
堆一样，是各个线程共享的内存区域，**它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。虽然
Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做
Non-Heap（非堆），目的应该是与 Java 堆区分开来。